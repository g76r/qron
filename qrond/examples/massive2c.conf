#(pf (version 1.0))
# configuration file to test qron tolerance to a high number of tasks execution
# (10 executions / second)
(config
 (maxtotaltaskinstances 128)
 (param global1 value1)

 # tasks
 (taskgroup massive(param p1 massive))
 (task true1(taskgroup massive)(mean local)
  (command /bin/true)
  (target localhost)
  (trigger(cron * * * * * *)(cron * * * * * *)(notice foo)(notice bar))
  (info http://www.google.com/)
  (maxinstances 10)
  (resource memory 103)
  (onstart(postnotice starting-%!taskid(param foo bar)))
  (onfinish(requesttask true5(param foo bar)))
  (minexpectedduration 1)
  (maxexpectedduration .001)
  (requestform
    (field(param p1)(label param1)
      (format "[0-9]{2}")
      (placeholder "nn")
    )
    (field(param p2)(label param2)
      (format "[0-9]{2}")
      (suggestion "42")
    )
  )
 )
 (task true2(taskgroup massive)(mean ssh)
  (command /bin/sleep 3600)
  (maxdurationbeforeabort .4)
  #(command /bin/true)
  (info this task can be run https://foo or http://bar)
  (target localhost)
  (trigger(cron * * * * * *))
  (resource memory 103)
  (minexpectedduration 1)
 )
 (task nocommand1(taskgroup massive)(mean local)
  #(command /bin/false)
  (target localhost)
  (trigger(cron * * * * * *))
  (resource memory 103)
  (maxexpectedduration .001)
  (maxdurationbeforeabort .4)
 )
 (task true3(taskgroup massive)(mean local)
  (command /bin/true)
  (target localhost)
  (trigger(cron * * * * * *))
  (resource memory 103)
  (maxdurationbeforeabort .4)
 )
 (task true4(taskgroup massive)(mean local)
  (command /bin/true)
  #(target localhost)
  (trigger(cron * * * * * *))
  (resource memory 103)
  (param clearsysenv true)
  (var 42 42)
 )
 (task true5(taskgroup massive)(mean local)
  (command /bin/true)
  (target localhost)
  (trigger(cron * * * * * *))
  (resource memory 103)
 )
 (task true_long1(taskgroup massive)(mean local)
  (command /bin/sleep 30)
  (target localhost)
  (trigger(cron /10 * * * * *))
 )
 (task notexist1(taskgroup massive)(mean local)
  (command /bin/notexist)
  (target localhost)
  (trigger(cron * * * * * *))
  (resource memory 103)
 )
 (task notexecutable1(taskgroup massive)(mean local)
  (command /etc/hosts)
  (target localhost)
  #(trigger(cron * * * * * *))
  (resource memory 103)
 )
 (task notarget1(taskgroup massive)(mean ssh)
  (command /bin/true)
  (trigger(cron * * * * * *))
 )
 (task donothing1(taskgroup massive)(mean donothing)
  #(command /qron/)
  #(target localhost)
  (trigger(cron * * * * * *))
 )
 (task poll1(taskgroup massive)(mean http)
  (command /qron/)
  (target localhost)
  (trigger(cron * * * * * *))
 )
 (task poll2(taskgroup massive)(mean http)
  (method put)
  (command /qron/)
  (target localhost)
  (trigger(cron * * * * * *))
  (param method post)
 )
 (task poll3(taskgroup massive)(mean http)
  (method post)
  (command /qron/)
  (target localhost)
  (trigger(cron * * * * * *))
  (param method put)
 )
 (task poll4(taskgroup massive)(mean http)
  (command /qron/)
  (target localhost)
  (trigger(cron * * * * * *))
 )
 (task poll5(taskgroup massive)(mean http)
  (command /qron/)
  (target localhost)
  (trigger(cron * * * * * *))
 )
 (task each_serialized1(taskgroup massive)
  (mean ssh)(command /bin/sleep 1)
  (target cluster1)
  (trigger (cron /10 * * * * *))
 )
 (task each_serialized_long1(taskgroup massive)
  (mean ssh)(command /bin/sleep 30)
  (target cluster1)
  (trigger (cron /10 * * * * *))
 )
 (task each_parallel1(taskgroup massive)
  (mean ssh)(command /bin/sleep 1)
  (target cluster1)
  (trigger (cron /10 * * * * *))
  (maxinstances 3)
 )
 (task each_parallel_long_1(taskgroup massive)
  (mean ssh)(command /bin/sleep 30)
  (target cluster1)
  (trigger (cron /10 * * * * *))
  (maxinstances 3)
 )
 (task clustered1(taskgroup massive)
  (mean ssh)(command /bin/sleep 1)
  (target cluster2)
  (trigger (cron /5 * * * * *))
 )
 # not massive but usefull for regression testing
 (taskgroup appli.wf)
 (task noticeposter(taskgroup appli.wf)(mean donothing)
   (trigger(cron 4/10 * * * * *))
   (onstart(postnotice foobar))
 )
 (task wf4(taskgroup appli.wf)(mean workflow)
  # workflow w/ a or step triggered by notice ^foobar
  # and a cron trigger that will fire too late
  (trigger(cron 1/10 * * * * *))
  (start s1)
  (subtask s1(mean local)(command /bin/false)(onsuccess(step 1)))
  (ontrigger
    (cron 6/10 * * * * *(param file /dev/null)) # trigger with param
    (notice foobar(param file /dev/null)) # several triggers per subscription
    (step 1) # actions
    #(log(severity FATAL)"*** ontrigger!!! ***")
  )
  (or 1(onready(step s2)))
  (subtask s2(mean local)(command /bin/true)(onfinish(end))
   (trigger(cron * * * * * *)(notice foobar)) # warning: subtasks do not have triggers
  )
 )
 (task wf5(taskgroup appli.wf)(mean workflow)
  # same workflow but this time the cron trigger fires before notice
  (trigger(cron 1/10 * * * * *))
  (start s1)
  (subtask s1(mean local)(command "/bin/false wf5p1=%wf5p1 global1=%global1 tasklocalid=%!tasklocalid")(onsuccess(step 1)))
  (param wf5p1 foobar)
  (ontrigger
    (cron 2/10 * * * * *(param file /dev/null))
    (notice foobar(param file /dev/null))
    (step 1)
    #(log(severity FATAL)"*** ontrigger!!! ***")
  )
  (or 1(onready(step s2)))
  (subtask s2(mean local)(command /bin/true)(onfinish(end)))
 )
 (task wf6(taskgroup appli.wf)(mean workflow)
  (trigger(cron 1/10 * * * * *))
  (start unzip backup)
  (subtask unzip(mean local)(command /bin/true)(onfinish(step 1)))
  (subtask backup(mean local)(command /bin/true)(onfinish(step 1)))
  (and 1(onready(step import_file)))
  (ontrigger(cron * 0 10 * * *)(step import_file))
  (subtask import_file(mean local)(command /bin/true)(onfinish(end)))
 )

 # infrastructure
 (host localhost(hostname localhost)(resource memory 8192))
 (host host1a(hostname localhost))
 (host host1b(hostname localhost))
 (host host1c(hostname localhost))
 (cluster cluster1(hosts host1a host1b host1c)(balancing each))
 (cluster cluster2(hosts host1a host1b)) # balancing first

 # alerts
 (alerts
  (subscription(pattern task.failure.app1.batch.*) # task.failure.%!taskid
        (mail(address gb@localhost, root@localhost))
   )
   (subscription(pattern task.failure.massive.**) # task.failure.%!taskid
        (url(address udp://127.0.0.1:4242)
            (emitmessage task failure: %!alertid)
            (cancelmessage task back to success: %!alertid))
        (mail(address nobody@localhost)) # this is an error 
        (stop) # do not process next rules if this one matches
   )
   (subscription(pattern resource.exhausted.**) # resource.exhausted.%!kind.%!target
        (mail(address gb@localhost))
   )
   (subscription(log(address debug)) # match every alert (but those stopped before)
        (url(address udp://localhost:4243))
   )
   (param mindelaybetweensend 60)
   (param canceldelay 90)
  (gridboard tasks
    (label Tasks Alerts)
    (pattern "^task\.(?<status>[^\.]+)\.(?<taskid>.+)$")
    (dimension taskid)
    (dimension status)
    (param gridboard.rowformat '<a href="taskdoc.html?taskid=%1">%1</a>')
  )
 )

 # events
 (onschedulerstart
  # add a custom debug log for scheduler start
  (log scheduler started!)
  # post a notice which can be used as task trigger
  (postnotice startup)
 )
 (onconfigload
  # add a custom fatal log for config reload
  (log(severity fatal) config reloaded!)
 )
 (onstart
  # add a custom debug log for task start
  (log(severity debug) started a task! *%!tasklocalid* "%{=date:yyyy}")
 )
 (onfinish
  (log(severity debug) finished a task! *%!tasklocalid*)
 )
 (onsuccess
  # sending UDP packets to statsd server, see https://github.com/etsy/statsd
  (requesturl(address udp://127.0.0.1:8125)"task.%!taskid.ok:1|c")
  (requesturl(address udp://127.0.0.1:8125)"task.%!taskid.time:%!totalms|ms")
  # add a custom debug log for task success
  (log(severity debug) task success! *%!tasklocalid*)
  # cancel a custom task failure alert
  (cancelalert failure.raised.%!taskid)
 )
 (onfailure
  # sending UDP packets to statsd
  (udp(address 127.0.0.1:8125)(message "task.%!taskid.ko:1|c"))
  # add a custom debug log for task failure
  (log(severity debug) task failure! *%!tasklocalid*)
  # raise and even emit custom task failure alerts
  (raisealert failure.raised.%!taskid)
  (emitalert failure.emited.%!taskid)
 )
 (onnotice
  # add a custom log every time a notice is posted
  (log notice posted! *%!notice*)
 )

 # log
 #(log(level debug)(file "/tmp/qron-debug.log"))
 #(log(level debug)(file "/tmp/qron-debug-%{=date:yyyy-MM-dd}.log"))
 #(log(level debug)(file "/tmp/qron-debug-%{=date:yyyy-MM-dd!04-01T01:20-2d+4h}.log"))
 #(log(level info)(file "/tmp/qron-%{=date:yyyy-MM-dd}.log")(unbuffered))
)
